<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>施振兴的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="施振兴的个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="施振兴的个人博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="施振兴的个人博客">
  
    <link rel="alternate" href="/atom.xml" title="施振兴的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/default-avatar.webp">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/highlight.css">
  <script>
  let antiquityStorage = window.sessionStorage.getItem('antiquitySessionStorage');
  if (antiquityStorage == '' || antiquityStorage == null) {
    var antiquityLoader = '<div id="loaderbox"><div class="loader"><div class="load-roll"><div class="load-top"></div><div class="load-right"></div><div class="load-bottom"></div></div></div></div>';
    document.write(antiquityLoader);
    document.body.style.overflow = 'hidden'
  }
  </script>
</head>
</html>
<body>
  <div id="fullpage" class="mobile-nav-right">
    
      <div id="wrapper" title="图片来自网络">
    
    
      <header id="header">
  <div id="nav-toggle" class="nav-toggle"></div>
  <div class="head-box global-width">
    <nav class="nav-box nav-right">
      
        <a class="nav-item" href="/" title>首页</a>
      
        <a class="nav-item" href="/archives" title>归档</a>
      
    </nav>
  </div>
</header>
      <div id="middlecontent" title class="global-width sidebar-right">
        <section id="main">
  
    <article id="post-addEventListener事件" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/04/addEventListener事件/">addEventListener事件</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/09/04/addEventListener事件/" class="article-date">
  <time datetime="2019-09-04T11:19:41.000Z" itemprop="datePublished">2019-09-04</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h1 id="务必要先点击这里！！！！"><a href="#务必要先点击这里！！！！" class="headerlink" title="务必要先点击这里！！！！"></a><a href="http://js.jirengu.com/hiwun/2/edit?html,js,console,output" target="_blank" rel="noopener">务必要先点击这里！！！！</a></h1><h2 id="1，addEventListenervsonclick"><a href="#1，addEventListenervsonclick" class="headerlink" title="1，addEventListenervsonclick"></a>1，<code>addEventListener</code>vs<code>onclick</code></h2><ul>
<li><p><code>onclick</code>在DOM1的标准中就已经出现了，<code>addEventListener</code>是DOM2才出现的。</p>
</li>
<li><p>由于onclick是一个方法，一个元素的方法是唯一的，多次更改方法只会覆盖前面的内容</p>
</li>
<li><p>虽然addEventListener也是一个方法，但是它的实现方式和onclick是不同的，一个元素只能有一个add，但是它可以存储多个事件</p>
</li>
<li><p>多个重复的事件之间不会产生覆盖，只会以队列的形式存入其中，（先进先出）</p>
</li>
</ul>
<h2 id="2-removeEventListener"><a href="#2-removeEventListener" class="headerlink" title="2, removeEventListener"></a>2, <code>removeEventListener</code></h2><ul>
<li><p>这是addEventListener的好基友，用来清除使用addEventListener监听的事件</p>
</li>
<li><p>可以用来实现一次性监听，当成功监听后，将监听事件清除</p>
</li>
</ul>
<h2 id="3，多层嵌套同时监听执行顺序"><a href="#3，多层嵌套同时监听执行顺序" class="headerlink" title="3，多层嵌套同时监听执行顺序"></a>3，<code>多层嵌套同时监听执行顺序</code></h2><ul>
<li><p>是由第三个参数决定的</p>
</li>
<li><p>与监听的顺序无关</p>
</li>
<li><p>出现这的多层情况时，触发后会对函数进行两次执行</p>
</li>
<li><p>第一次1，2，3，可能不会做出反应，因为比较怂</p>
<ul>
<li>1，爷爷有人打你</li>
<li>2，爸爸有人打你</li>
<li>3，孙子有人打你</li>
</ul>
</li>
<li><p>第二次4，5，6,如果第一次没有做出反应第二次就会做出反应</p>
<ul>
<li>4，孙子有人打你</li>
<li>5，爸爸有人打你</li>
<li>6，爷爷有人打你</li>
</ul>
</li>
<li><p>当第三个参数为falsy值得时候，就比较怂第一次不会做出反应，你再告诉他一次他就会有反应了</p>
</li>
<li><p>当为true时，就会变成true男人，第一次知道挨打了就会不能忍，之间就有反应了。</p>
</li>
</ul>
<ul>
<li><p>所以默认情况下参数3是<code>undefined</code>，大家都不是真男人，都会在第二字才有反应</p>
</li>
<li><p>但是第二次是从孙开始提醒的，所以顺序是孙–&gt;爹–&gt;爷</p>
</li>
<li><p>如果大家上来都是真男人，那就是从爷开始提醒一遍就有反应了</p>
</li>
<li><p>顺序是爷–&gt;爹–&gt;孙</p>
</li>
<li><p>如果这祖孙三人性格迥异，那么顺序就会发生变化。</p>
</li>
</ul>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-实现jQuery部分功能" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/03/实现jQuery部分功能/">实现jQuery部分功能</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/09/03/实现jQuery部分功能/" class="article-date">
  <time datetime="2019-09-03T03:28:30.000Z" itemprop="datePublished">2019-09-03</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>二话不说先上代码<a href="http://js.jirengu.com/kotod/5/edit?html,js,output" target="_blank" rel="noopener">代码位置</a></p>
<p>这个和方方老师课上的实现有所不同</p>
<ul>
<li><p>这个功能在原有基础上做了升级：</p>
<p>  1，addClass更名为changeClass，分别有三个模式，增（1）删（2）改（3）。</p>
<p>  2，changeClass均可实现同时更改多个元素</p>
<p>  3，还可以同时增加或删除多个class</p>
<p>  4，text可以同时获取/修改多个元素文本内容</p>
<p>  5，可以实现链式操作</p>
<p>  6，实现原理和课上讲的不同，使用了bind将this硬绑定到三个模块中。</p>
<p>  7,sibling方法可以通过传入一个非falsy值来将目标函数加入返回值。</p>
<ul>
<li><p>现有问题：我并没有想实现sibling同时获取多个目标的兄弟，我暂时没想什么时候会有这样的需求。</p>
</li>
<li><p>遇到的坑</p>
<ul>
<li><p>主要问题在于可以自动区分传入的是什么，三种情况：</p>
<p>1，HTMLCollection对象（伪数组）</p>
<p>2,一个元素</p>
<p>3，字符串</p>
</li>
<li><p>字符串其实比较容易分辨，当是字符串的时候就对它使用DOM提供的querySelectorAll方法,获取到NodeList。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>       //如果是字符串就调用querySelectorAll方法，如果不是就就直接直接赋给target原值。
        target = typeof target === &apos;string&apos; ? document.querySelectorAll(target) : target;


  * 到上面一步其实都没有什么问题，主要是后面要区分到底的道德是一个元素，还是一个伪数组，

  * 伪数组可能是NodeList也有可能是HTMLCollection但是在这里没什么影响。

  * 将this转换成数组，这个长度是1就是一个元素，大于一就是一个伪数组

  * 如果是一个元素，直接加`[]`就可以将它转换成数组

  * 如果是一个伪数组，就调用slice方法将其转换成数组

         //可以判断转换过的this到底是元素还是个伪数组
         const thisContent = Array.prototype.slice.apply(this).length === 0 ? [this] : Array.prototype.slice.apply(this);


* 现在不管之前this到底是哪个，都被变成了数组，调用forEach方法，对其进行处理，就可以得到最后的结果。</code></pre><ul>
<li><p>如何实现对一个元素的class的修改，这个其实不算难，但是还是写一下吧。</p>
<ul>
<li>注意顺序<ul>
<li>要先搜索是否存在要修改的目标</li>
<li>如果存在就将要更改的内容先添加</li>
<li>然后不管存不存在都可以删除目标，因为不存在就不会发生改变</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>  if (tergetCon.indexOf(content[0]) !== -1) {

  tar.classList.add(content[1]);
}
 tar.classList.remove(content[0]);</code></pre>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-Array对象" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/29/Array对象/">Array对象</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/08/29/Array对象/" class="article-date">
  <time datetime="2019-08-29T11:09:19.000Z" itemprop="datePublished">2019-08-29</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href></a><br><a href></a><br><a href></a><br><a href></a><br><a href></a></p>
<h3 id="1，创建新数组"><a href="#1，创建新数组" class="headerlink" title="1，创建新数组"></a>1，创建新数组</h3><p>创建一个新数组方法很多，可以使用它的构造函数Array</p>
<pre><code>var arr = new Array(2);     //创建一个有两个成员的空数组，每一个成员都是empty但是显示的值是undefined
var arr = Array(2);         //效果同上</code></pre><p>阮一峰老师并不建议使用这种方式，</p>
<ul>
<li><p>书写麻烦* 行为不一致</p>
<pre><code>// 无参数时，返回一个空数组
new Array() // []

// 单个正整数参数，表示返回的新数组的长度
new Array(1) // [ empty ]
new Array(2) // [ empty x 2 ]

// 非正整数的数值作为参数，会报错
new Array(3.2) // RangeError: Invalid array length
new Array(-3) // RangeError: Invalid array length

// 单个非数值（比如字符串、布尔值、对象等）作为参数，
// 则该参数是返回的新数组的成员
new Array(&apos;abc&apos;) // [&apos;abc&apos;]
new Array([1]) // [Array[1]]

// 多参数时，所有参数都是返回的新数组的成员
new Array(1, 2) // [1, 2]
new Array(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]      </code></pre></li>
</ul>
<p>其实可以直接使用[]</p>
<pre><code>var arr = [1,2,,];       //(3)[1,2,empty]</code></pre><p>关于empty</p>
<p>它表示一个空的位，读取的时候会返回undefined，但是当你对它取键名的时候会失败</p>
<pre><code>var a = Array(2);
var a2 = [undefined,undefined];

a[0]         //undefined
a2[0]        //undefined

a.length     //3
a1.length    //3

0 in  a;      //false
0 in  a1      //true</code></pre><h3 id="2，静态方法"><a href="#2，静态方法" class="headerlink" title="2，静态方法"></a>2，静态方法</h3><p><code>isArray()</code>当时用typeof对数组类型进行处理时，会返回Object，isArray解决了没办法区分对象和数组的问题。</p>
<pre><code>var arr = [1,2,3];
typeof arr;             //&apos;Object&apos;
Array.isArray(arr);     //true</code></pre><p>###3，不改变原数组的方法</p>
<p>3.1 <code>valueOf()</code>返回数组本身</p>
<p>3.2 <code>toString()</code>返回数组的字符串形式</p>
<p>3.3 <code>join()</code>有点类似toString，不提供参数的情况下与toString相同,参数决定了将数组转化成字符串后，每一个元素之间的分隔符</p>
<pre><code>var a = [1,2,3,4];
a.toString() === a.join();                //&quot;true&quot;
a.join(&apos;?&apos;);                              //&quot;1?2?3?4&quot;

var b = [,,,];
b.join();                                 //&quot;,,,&quot;</code></pre><ul>
<li>可以通过<code>call</code>对于字符串或<strong>类似</strong>的对象进行处理</li>
</ul>
<pre><code>Array.prototype.join.call(&apos;hehe&apos;,&apos;,&apos;)           //h,e,h,e

var obj = {0:&apos;g&apos;,1:&apos;o&apos;};
Array.prototype.join.call(obj,&apos;,&apos;)              //g,o</code></pre><p>3.4 <code>concat()</code>合并多个数组，返回新数组。当连接两个数组的时候和<code>+</code>的行为方式完全相同,但是如果连接的内容不是数组，就无法使用<code>+</code></p>
<pre><code>var a = [1,2,3];

a.concat(&apos;sss&apos;);        //[1,2,3,&apos;sss&apos;];
//将数组转换成了字符串形式
a+&apos;sss&apos;;                //’1，2，3sss‘</code></pre><p>3.5 <code>slice</code>提取数组的一部分，返回新数组   <code>arr.slice(start,end)</code>slice可以理解成切片，这两个参数其实有点特别。</p>
<ul>
<li><p>从start元素和ende元素的前面，返回剩下的中间一部分。</p>
<pre><code>var a = [1,2,3,4];
a.slice(1,2);                 //[2]</code></pre></li>
<li><p>如果只有一个参数，就会从start前面切一刀，返回剩下的</p>
<pre><code>var a = [1,2,3];
a.slice(1);             //[2,3]
a.slice(5);             //[]</code></pre></li>
<li><p>负数的时候,就是从后向前数，然后在相应元素的前面切一刀。</p>
<pre><code>var a = [1,2,3,4,5,6,7];

a.slice(-1);            //[7]
a.slice(-3,-1);         //[5,6]    </code></pre></li>
<li><p>还可以将类似字符穿的对象转换成数组</p>
<pre><code>Array.prototype.slice.call({0:&apos;a&apos;,1:&apos;b&apos;,length:2});            //[&apos;a&apos;,&apos;b&apos;] 

//比较常见的arguments以及querySelectorAll方法

Array.prototype.slice.call(arguments)</code></pre></li>
</ul>
<p>3.6    <code>map</code>将数组的内容依次传入函数，返回值传入新数组。</p>
<ul>
<li><p>语法：<code>arr.map(function(elem,index,arr),this指向)</code></p>
</li>
<li><p>解释一下哈，map方法本身可以可以传入两个参数，一个函数，一个this的指向(还有一个隐含的就是当前这个数组)。而它里面的function也可以传入三个参数，分别是elem数组的值、数组的index、当前数组。这三个是可选的。</p>
</li>
</ul>
<pre><code>var a = [&apos;ruby&apos;,&apos;peppa&apos;,&apos;coco&apos;];
a.map(function (value,key,arr){

    console.log(&apos;value = &apos; + value);
    console.log(&apos;key = &apos; + key);
    if(key === 2 ){
        console.log(arr);
    }
    return key
})

//value = ruby
//key = 0
//value = peppa
//key = 1
//value = coco
//key = 2
//(3) [&quot;ruby&quot;, &quot;peppa&quot;, &quot;coco&quot;]
//(3) [0, 1, 2]</code></pre><p>3.7    <code>forEach</code>  它和<code>map</code>十分相似，惟一的区别就是<code>forEach</code>不会返回一个新数组。</p>
<p>3.8 <code>filter</code> 这个单词可以理解成过滤器，他就是将数组过滤，将过滤出来的元素放入一个新的数组</p>
<ul>
<li><p>语法：<code>arr.filter(function(elem,index,arr){},this指向)</code></p>
</li>
<li><p>它里面传入的内容和map完全一样，function的三个参数也是一模一样 </p>
</li>
<li><p>retrun返回true的元素会被复制进新的数组</p>
<pre><code>var a = [1,2,3,4,5,6];
var b = [1,2,6,5,3,6];
a.filter(function(elem,index,arr){

    return elem === this[index];

},b)

//[1,2,6]</code></pre></li>
</ul>
<p>3.9 <code>some()</code>&amp;<code>every()</code></p>
<ul>
<li><p>这两个类似<code>或</code>和<code>与</code>。</p>
</li>
<li><p><code>some</code>传入函数的返回值都有true那么<code>some</code>的返回值就是true</p>
</li>
<li><p><code>every</code>传入函数的返回值都是true，<code>every</code>也会返回true,返回值有false，<code>every</code>就会返回false。</p>
</li>
<li><p>arr.some(function(elem,index,arr){},this指向)</p>
</li>
<li><p>every的语法也一样，下面只举一个some的例子</p>
<pre><code>var a = [1,2,3];
var b = [4,5,6];
a.some(function(elem,index,arr){
    return this[index]&gt;elem;
},b)
//true</code></pre></li>
</ul>
<p>3.10 <code>reduce()</code>&amp;<code>reduceRight()</code></p>
<ul>
<li><p><code>reduce</code>在这里最贴切的翻译应该是<code>归纳为</code>，因为它的作用就是将整个数组的所有归纳到一起。</p>
</li>
<li><p><code>reduceRight()</code>就是从右往左归纳</p>
</li>
<li><p>语法：arr.reduce(function(a,b,c,d),start)</p>
</li>
<li><p>如何归纳就是由传入函数的返回值来决定了</p>
</li>
<li><p>这个函数的参数和之前就很不同了，</p>
<ul>
<li>a累计变量，初始为arr[0]</li>
<li>b当前变量，初始为arr[1]</li>
<li>当前位置，初始为0</li>
<li>原数组</li>
</ul>
</li>
<li><p>start初始值，将累计变量的初始值</p>
<pre><code>var a = [1,2,3,{name:11},&apos;llala&apos;,22,true];

a.reduce(function(a,b){

    return a+b;

});
//&quot;6[object Object]llala22true&quot;</code></pre></li>
</ul>
<p>3.11 <code>indexOf()</code>&amp; <code>lastIndexOf()</code></p>
<ul>
<li><code>indexOf</code>返回给定元素在数组中第一次出现的位置，-1代表不存在</li>
<li><code>lastIndexOf</code>返回元素在数组中最后一次出现的位置，不出现也返回-1</li>
<li><code>NaN</code>比较特别不能被搜索到</li>
<li>语法：arr.indexOf(target,start)</li>
<li>target是目标元素，start是搜索的起始位置，默认0</li>
</ul>
<h3 id="4，改变原数组的方法"><a href="#4，改变原数组的方法" class="headerlink" title="4，改变原数组的方法"></a>4，改变原数组的方法</h3><p>4.1这两兄弟的行为模式，就像是栈先进后出</p>
<p><code>push()</code>在数组的末端添加一个或多个元素，可以接受多个参数<br><code>pop()</code>删除数组的最后一个元素</p>
<p>4.2这两兄弟的行为模式，就像是堆先进先出</p>
<p><code>shift()</code>删除数组的开头元素<br><code>unshift()</code>在数组的开头添加一个元素，可以接受多个参数</p>
<p>4.3 <code>reverse()</code>颠倒数组</p>
<ul>
<li>语法<code>arr.reverse()</code> </li>
</ul>
<p>4.4 <code>splice()</code>这个可以删除数组的一部分，并且可以再删除的部分添加新的元素      语法<code>arr.splice(start, count, addElement1, addElement2, ...);</code></p>
<ul>
<li><p>ps.乍一看长得好像slice哦，但是这俩的功能可以说是大相径庭。splice这个单词的意思粘接。可以这样理解，一张纸，从中间剪下了一块，然后用胶带直接粘住，或者是在拿一块纸，从你剪下来的部分补上。</p>
</li>
<li><p>Note它是直接对原数组做处理的，会把剪下来的一部分返还给你,它是从start元素前面下刀(只有这一点像slice哦)，剪下count个元素哦</p>
<pre><code>var a = [1,2,3,4,5,6,7];
a.splice(2,3);                    //[3,4,5]
a;                                //[1,2,6,7]</code></pre></li>
<li><p>也可以从后往前剪</p>
<pre><code>var a = [1,2,3,4,5,6,7];
a.splice(-2,1);                    //[6]
a;                                //[1,2,3,4,5,7]</code></pre></li>
<li><p>当第二个参数是0就可以单纯插入元素</p>
<pre><code>var a = [1,2,3,4,5,6,7];
a.splice(3,0,6,6,6);
a;                                //[1, 2, 3, 6, 6, 6, 4, 5, 6, 7]</code></pre></li>
</ul>
<ul>
<li><p>如果只提供第一个参数，就会从start删到最后</p>
<pre><code>var a = [1,2,3,4,5,6,7];
a.splice(4);                    //[5,6,7]
a;                                //[1,2,3,4]</code></pre></li>
</ul>
<p>4.5 <code>sort()</code>对数组进行排序</p>
<ul>
<li><p>没有参数时，会按照字典顺序。这意味着他不按照大小排序，当数值排序时，会先转换成字符串在进行排序。</p>
<pre><code>var a = [&apos;e&apos;,&apos;a&apos;,&apos;c&apos;];
a.sort();                    //[&apos;a&apos;,&apos;c&apos;,&apos;e&apos;]

var b = [12,333,1111,2222,4,55];
b.sort()                    //[1111, 12, 2222, 333, 4, 55]</code></pre></li>
<li><p>可以传入一个函数，让sort按照自定义的方式排序,常见的方式如下</p>
<pre><code>    var a = [34,666,221,1234,33123];
    var sorting = function(x,y){

        return x-y;

    }

    a.sort(storing);            //[34,221,666,1234,33123]

sort会将数组的值从0到最后两两依次传入这个函数，函数对于这两个值进行处理，对返回值的大小进行处理。</code></pre></li>
<li><p>一般常用的情况如下</p>
<pre><code>var obj ={ 
    peppa:23,
    ruby:13,
    coco:21
    };

var a = [&apos;peppa&apos;,&apos;ruby&apos;,&apos;coco&apos;];

a.sort(function (x,y){

    return obj[x] - obj[y]

});                            //[&apos;ruby&apos;,&apos;coco&apos;,&apos;peppa&apos;]</code></pre></li>
</ul>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-原型链" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/28/原型链/">原型链</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/08/28/原型链/" class="article-date">
  <time datetime="2019-08-28T07:45:17.000Z" itemprop="datePublished">2019-08-28</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <ul>
<li><p>前言</p>
<p>关于原型我酝酿了好几天，看了网道的教材，看了你不知道的js不过还没有看完相关的内容。于是决定先写一篇关于饥人谷原型链课程的总结。不能耽误了任务的进度。</p>
</li>
</ul>
<p>  这篇文章写给明白什么是this new的读者，如果不懂就别看下去了。日后会有相关的全面的博客，现在还在酝酿。</p>
<ul>
<li><p>我的理解。</p>
<p>当你new 通过构造函数创建了一个对象实例后，正常情况下每个实例的属性都是独立的，大家虽然都是兄弟姐妹，但是每个人高矮胖瘦不同，而且性格迥异。</p>
<p>但是，在创造啊构造函数的时候，可以给它这么一个属性prototype。一旦new在创造实例的时候看到了他，就会为创造出来的对象添加一个与其相对应的属性<strong>proto</strong>。</p>
</li>
<li><p>这有啥用呢？</p>
<p>很多时候，虽然一队兄弟有很多不同，但是他们毕竟同父同母，基因还是会非常相似。而这个prototype就是存储这些对象之间的共用属性。</p>
</li>
</ul>
<ul>
<li><p>js引擎是如何处理它的呐？</p>
<pre><code>function cat(name){

  this.name = name;</code></pre></li>
</ul>
<pre><code>}

cat.prototype.color = &quot;yellow&quot;



var cat1 = new cat(&quot;pappe&quot;);
var cat2 = new cat(&quot;ruby&quot;);

cat1.color;         //yellow
cat1.name;          //pappe

cat2.color;          //yellow
cat2.name;           //ruby</code></pre><p>  当添加了prototype属性，new在通过构造函数创建实例的时候就会将这里面的内容通过某种方式使得实例可以访问它。当你想要使用实例的某个属性或者方法，引擎会先在普通的属性中寻找，找不到就会跑到prototype中去找，如果找到了就会使用，找不到就显示undefined。</p>
<ul>
<li>如何存储这个prototype</li>
</ul>
<p>  在创建好的对象中，有这么一个特别的属性<strong>proto</strong>它里面放的就是构造函数的prototype属性（函数.prototype在内存中是一个对象）的地址，引擎就是通过这个<strong>proto</strong>来找到相对应的prototype</p>
<ul>
<li><p>var 对象 = new 函数();</p>
<p>对象.<strong>proto</strong> === 函数.prototype;</p>
<p>下图就是创建了一个构造函数foo。通过foo创建了两个实例b，c这两个实例的<strong>proto</strong>都指向foo.prototype，而构造函数本身也是由一个js内置的构造函数Function创建的，所以foo.<strong>proto</strong>指向了Function.prototype这个对象，Function是由Object这个构造函数创建出来的，所以Function.prototype的<strong>proto</strong>就指向了Object.prototype，Object就是这棵树的定点，它的上面就是虚无。Object.prototype的<strong>proto</strong>最终指向了Null<br><img src="/zjyshy.github.io/img/__proto__VSprototype.png" alt="继承"></p>
</li>
</ul>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-面试题" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/15/面试题/">面试题</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/08/15/面试题/" class="article-date">
  <time datetime="2019-08-15T10:26:32.000Z" itemprop="datePublished">2019-08-15</time>
</a>
    
    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="1，对象"><a href="#1，对象" class="headerlink" title="1，对象"></a>1，对象</h3><hr>
<h5 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h5><p>  Q:此时打印出的a.x和b.x的值分别是多少?</p>
<pre><code>var a =  {n:1};
var b = a;
a.x = a = {n:2};

console.log(a.x);
console.log(b.x);</code></pre><p>  <span style="color :red" title="//undeffined  //{n:2}">鼠标悬停看答案</span></p>
<p>  解释：这个体主要的考点在于第三行，对于js符号优先级和语句执行时步骤的顺序。</p>
<ul>
<li><p>第一行和第二行：假设初始a指向100，则b指向也是100。</p>
</li>
<li><p>第三行：</p>
<ul>
<li><p>a.x = a = {n:2}浏览器是自左向右看代码，第三句是先将两个指向100的a准备好, 此时两个a都指向100</p>
</li>
<li><p>a = {n:2}:因为<code>=</code>是自右向左。此时a指向了200，左边是早已准备好的指向100的指针。</p>
</li>
<li><p>a.x:为100号内存空间添加属性x</p>
</li>
<li><p>a.x = a:将a指向的新地址存入地址为100内存空间的x属性</p>
</li>
</ul>
</li>
</ul>
<h5 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h5><p>  <strong>Q</strong>：打印出来的内容是什么</p>
<pre><code>var a = false;

var b = new Boolean(false);

if(a)console.log(1);

if(b)console.log(2)</code></pre><p>  解释：这个题目考察的是对于falsy值的记忆，因为a是基本类型<code>false</code>，b是一个对象，对象代表的布尔值是true。</p>
<p><span style="color :red" title="//2">鼠标悬停看答案</span></p>
<hr>
<h3 id="2，垃圾回收"><a href="#2，垃圾回收" class="headerlink" title="2，垃圾回收"></a>2，垃圾回收</h3><p>  垃圾回收：如果一个对象没有被引用，那他就是垃圾，将被浏览器回收。IE6对于垃圾回收有BUG</p>
<h5 id="1-1-1"><a href="#1-1-1" class="headerlink" title="1.1"></a>1.1</h5><p>  <strong>Q</strong>:现在的function()会不会被浏览器回收</p>
<pre><code>var fn = function(){}

documnet.body.onclick = fn;

fn = null; </code></pre><p>  <span style="color :red" title="NO">鼠标悬停看答案</span></p>
<p>  解释：因为function()这个对象在第二行被引用了。</p>
<h5 id="2"><a href="#2" class="headerlink" title="2,"></a>2,</h5><p><strong>Q</strong>：n.xxx会不会报错，如果不报错最终值又是多少</p>
<pre><code>var n = 1;
n.xxx = 1;           
n.xxx;                //undefined</code></pre><p> <span style="color :red" title="//不会报错  //undefined">鼠标悬停看答案</span></p>
<p>  解释：<br>  由于n是一个基本类型，它本身并没有方法，也不能对他进行<code>.</code>操作。</p>
<p>  当需要对n执行<code>.</code>操作时，会先创建一个temp来过渡,当结束后temp就会别销毁掉。</p>
<pre><code>//暗中执行的操作
var temp = new Nember(n);
temp.xxx = 1;</code></pre><h2 id="Css"><a href="#Css" class="headerlink" title="Css"></a>Css</h2><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-function" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/15/function/">function</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/08/15/function/" class="article-date">
  <time datetime="2019-08-15T05:10:27.000Z" itemprop="datePublished">2019-08-15</time>
</a>
    
    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-JS数据类型" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/13/JS数据类型/">JS数据类型</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/08/13/JS数据类型/" class="article-date">
  <time datetime="2019-08-13T02:27:31.000Z" itemprop="datePublished">2019-08-13</time>
</a>
    
    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><strong><a href="#1，简介">1，简介</a></strong></p>
<p><strong><a href="#2，typeof">2，typeof</a></strong></p>
<p><strong><a href="#3，null和undefined">3，null和undefined</a></strong></p>
<p><strong><a href="#4，Number">4，Number</a></strong></p>
<p><strong><a href="#5，字符串">5，字符串</a></strong></p>
<p><strong><a href="#6，对象">6，对象</a></strong></p>
<p><strong><a href="#7，类型的转换">7，类型的转换</a></strong></p>
<hr>
<h3 id="1，简介"><a href="#1，简介" class="headerlink" title="1，简介"></a>1，简介</h3><p>js的数据类型可以分为两个大类</p>
<ul>
<li><p>简单类型（基本类型)</p>
<ul>
<li>Number :整数或者小数</li>
<li>String ： 文本</li>
<li>Boolean ：true和false两个特殊值</li>
<li>undefined ：未定义的值</li>
<li>null ：空值 </li>
<li>symbol ：</li>
</ul>
</li>
<li><p>复杂类型（合成类型）</p>
<ul>
<li>Object：各种值得集合<ul>
<li>狭义的对象</li>
<li>数组</li>
<li>函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2，typeof"><a href="#2，typeof" class="headerlink" title="2，typeof"></a>2，typeof</h3><p>typeof的作用是返回一个值的数据类型</p>
<p>除此之外还有一个运算符和一个方法可以确定一个值的数据类型。</p>
<ul>
<li><p>typeof对于各种数据类型的返回值</p>
<pre><code>typeof 1          //number
typeof &quot;aa&quot;       //string
typeof true       //boolean
typeof undefined  //undefined
function a(){}
typeof a          //function
typeof null       //object
typeof {}         //object
typeof []         //object</code></pre></li>
</ul>
<hr>
<h3 id="3，null和undefined"><a href="#3，null和undefined" class="headerlink" title="3，null和undefined"></a>3，null和undefined</h3><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p>  在大多数的编程语言中并没有使用两个值来表示空这一概念。在设计之初，Eich其实只涉及了<code>null</code>，但他后来觉得不妥，就又加了一个<code>undefined</code>。</p>
<p>  将一个变量赋值为<code>undefined</code>或是<code>null</code>的语法效果基本没有任何区别。</p>
<pre><code>null == undefined     //true
null === undefinded   //false</code></pre><h4 id="3-2-区别"><a href="#3-2-区别" class="headerlink" title="3.2 区别"></a>3.2 区别</h4><ul>
<li><p><code>null</code>表示一个空的对象，当把它转换为数值的时候可以自动转变成0,<br><code>undefined</code>则不行。</p>
<p>Number(null);      // 0<br>Number(undefined)  //NaN</p>
</li>
<li><p>使用的场景不同</p>
<ul>
<li><code>undefined</code></li>
</ul>
</li>
</ul>
<pre><code>    1,声明变量但是没有赋值

      var test;                   //undefined

  2,调用函数时，应该提供的参数没有被提供

      function test1(a){
        return a;
      }

      test1();                    //undefined

  3,对象没有赋值的属性

      window.aaaaa;               //undefined

  4,没有设置返回值的函数，默认返回值就是undefined


      function test4(){

      }

      test4();                    //undefined





* `null`

  `null`表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入`null`，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入`null`，表示未发生错误。</code></pre><hr>
<h3 id="4，Number"><a href="#4，Number" class="headerlink" title="4，Number"></a>4，Number</h3><h4 id="4-1-整数和浮点数"><a href="#4-1-整数和浮点数" class="headerlink" title="4.1 整数和浮点数"></a>4.1 整数和浮点数</h4><p>  与c语言不同，js所有的数字都是用<strong>64位浮点数</strong>来表示的。但是有些运算只有整数才能完成，此时js会将64位浮点数，转换成<strong>32位整数</strong>。</p>
<ul>
<li>由于计算机对于浮点数的存储机制，决定了浮点数结算结果有时不会是特别精确的值。</li>
</ul>
<pre><code>0.1 + 0.2 === 0.3         //false


0.7 / 0.1                 //0.999999999999999


(0.6-0.3) === (0.7-0.4)   //false</code></pre><ul>
<li><p>js可以精确表示-2^53^ 到 2^53^ ,当大于这个数的时候就无法保持精度，这个数是16位，即js可以保证<strong>15</strong>位数的计算精度。</p>
<pre><code>Math.pow(2,53)     //9007199254740992
Math.pow(2,53)+1   //9007199254740992</code></pre></li>
</ul>
<ul>
<li><p>js可以表示2^1024^ 到 2^-1023^</p>
<ul>
<li>大与1024次方发生”正向溢出”</li>
</ul>
</li>
</ul>
<pre><code>Math.pow(2,1025)        //Infinity</code></pre><ul>
<li><p>小于-1075(指数部分-1023和小数部分的52位)次方发生”负向溢出”</p>
<pre><code>Math.pow(2,-1075)      //0</code></pre></li>
</ul>
<ul>
<li><p>Number对象的<code>MAX_VALUE</code>和<code>MIN_VALUE</code>分别返回js所能表示的最大的数</p>
<pre><code>Number.MAX_VALUE      // 1.7976931348623157e+308
Number.MIN_VALUE      // 5e-324</code></pre></li>
</ul>
<hr>
<h4 id="4-2数值的表示法"><a href="#4-2数值的表示法" class="headerlink" title="4.2数值的表示法"></a>4.2数值的表示法</h4><ul>
<li><p>科学计数法，一个整数 + e +指数部分</p>
<pre><code>111e10              //1110000000000</code></pre></li>
</ul>
<ul>
<li><p>有两种情况会让js自动转为科学计数法</p>
<ul>
<li><p>小数点前多与21位</p>
<pre><code>1231131231231231231234   //1.2311312312312311e+21</code></pre></li>
</ul>
</li>
</ul>
<pre><code>* 小数点后的0多与5个


      0.0000001               //1e-7</code></pre><hr>
<h4 id="4-3数值的进制"><a href="#4-3数值的进制" class="headerlink" title="4.3数值的进制"></a>4.3数值的进制</h4><p>  对于各种进制在js的写法</p>
<ul>
<li><p>2进制  加前缀<code>0b</code>或者<code>0B</code>的数值</p>
</li>
<li><p>8进制  加前缀<code>0O</code>或者<code>0o</code>的数值</p>
</li>
<li><p>16进制 加前缀<code>0x</code>或者<code>0X</code>的数值</p>
</li>
<li><p><em>PS*</em>:如果在一个数值前加<code>0</code>并且这个数的每一位都<strong>小于</strong>8，name也可以用来表示8进制，否则就是十进制。</p>
</li>
</ul>
<p>  当相应进制中出现了不属于该进制的数值，那么便会报错</p>
<h4 id="4-4-特殊值"><a href="#4-4-特殊值" class="headerlink" title="4.4 特殊值"></a>4.4 特殊值</h4><h5 id="1-0"><a href="#1-0" class="headerlink" title="1) 0"></a>1) <code>0</code></h5><pre><code>`+0`和`-0`，js里面的0有两个，它们完全等价，几乎所有场合他们都会被当做一个普通的`0`来使用，唯一的区别是在当**分母**的的时候。

    0 === +0     //true
    0 === -0     //true
    +0 === -0    //true


    1/0        //Infinity
    1/+0       //Infinity
    1/-0       //-Infinity</code></pre><p>#####2) <code>NaN</code></p>
<h6 id="1-含义"><a href="#1-含义" class="headerlink" title="(1)含义"></a>(1)含义</h6><pre><code>它主要出现在将字符串解析成数字出错的场合

  1-&apos;e&apos;              //NaN    


它本身类型属于`Number`

  typeof NaN         //Number


一些计算出现问题也会返回NaN

  Math.acos(2)       // NaN
  Math.log(-1)       // NaN
  Math.sqrt(-1)      // NaN
  0/0                //NaN</code></pre><h6 id="（2）运算规则"><a href="#（2）运算规则" class="headerlink" title="（2）运算规则"></a>（2）运算规则</h6><p>  它不等于任何值，包括它本身</p>
<pre><code>NaN === NaN       //false</code></pre><p>  与任何数运算得到NaN</p>
<pre><code>1+NaN             //NaN</code></pre><h6 id="3-isNaN"><a href="#3-isNaN" class="headerlink" title="(3)isNaN"></a>(3)<code>isNaN</code></h6><h5 id="3-Infinity"><a href="#3-Infinity" class="headerlink" title="3) Infinity"></a>3) <code>Infinity</code></h5><p><code>Infinity</code>大于一切<strong>数值</strong>，<code>-infinity</code>小于一切<strong>数值</strong>,但是两者与<code>NaN</code>比较的结果都是false</p>
<pre><code> Infinity &gt; NaN    //false
-Infinity &gt; NaN    //false
 Infinity &lt; NaN    //false
-Infinity &lt; NaN    //false</code></pre><hr>
<h3 id="5，字符串"><a href="#5，字符串" class="headerlink" title="5，字符串"></a>5，字符串</h3><p>用’’或””或``包起来的一个或者多个字符就是字符串。</p>
<h4 id="5-1换行书写"><a href="#5-1换行书写" class="headerlink" title="5.1换行书写"></a>5.1换行书写</h4><h5 id="1）使用"><a href="#1）使用" class="headerlink" title="1）使用+"></a>1）使用<code>+</code></h5><pre><code>var str = &quot;a&quot;
          +&quot;b&quot;;      

a             //ab</code></pre><h5 id="2"><a href="#2" class="headerlink" title="2) `"></a>2) `</h5><pre><code>var str  = `aaa
aaa
aaa`;

str                 //aaaaaaaaa</code></pre><h5 id="3"><a href="#3" class="headerlink" title="3) \"></a>3) <code>\</code></h5><p>   这种方式很容易出现问题，当反斜杠后面有任何内容，包括空格，都会导致报错。</p>
<pre><code>var str = &quot;aaa\
          aaa\
          aaa&quot;;


    str               //aaaaaaaaa</code></pre><h4 id="5-2转义字符"><a href="#5-2转义字符" class="headerlink" title="5.2转义字符\"></a>5.2转义字符<code>\</code></h4><h5 id="1）一些常用的转义字符"><a href="#1）一些常用的转义字符" class="headerlink" title="1）一些常用的转义字符"></a>1）一些常用的转义字符</h5><pre><code>\0 ：null（\u0000）
\b ：后退键（\u0008）
\f ：换页符（\u000C）
\n ：换行符（\u000A）
\r ：回车键（\u000D）
\t ：制表符（\u0009）
\v ：垂直制表符（\u000B）
\&apos; ：单引号（\u0027）
\&quot; ：双引号（\u0022）
\\ ：反斜杠（\u005C）</code></pre><h5 id="2）三种特殊用法"><a href="#2）三种特殊用法" class="headerlink" title="2）三种特殊用法"></a>2）三种特殊用法</h5><ul>
<li><p>\HHH</p>
<p> 反斜杠后面紧跟三个八进制数（000到377），代表一个字符。HHH对应该字符的 Unicode 码点，比如\251表示版权符号。显然，这种方法只能输出256种字符。</p>
</li>
<li><p>\xHH</p>
<p> \x后面紧跟两个十六进制数（00到FF），代表一个字符。HH对应该字符的 Unicode 码点，比如\xA9表示版权符号。这种方法也只能输出256种字符。</p>
</li>
<li><p>\uXXXX</p>
<p> \u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。XXXX对应该字符的 Unicode 码点，比如\u00A9表示版权符号。</p>
</li>
</ul>
<h4 id="5-3-字符串与数组"><a href="#5-3-字符串与数组" class="headerlink" title="5.3 字符串与数组"></a>5.3 字符串与数组</h4><p>  可以通过数组来使用显示字符串，但是并不可以被修改。</p>
<pre><code>var test = &quot;Hello&quot;;
test[0]         //H

test[8]         //undefined

test[0] = &quot;h&quot;;
test;           //Hello</code></pre><h4 id="5-4-length属性"><a href="#5-4-length属性" class="headerlink" title="5.4 length属性"></a>5.4 length属性</h4><p>  返回字符串长度，但是也没办法改变。</p>
<p>  var test = “hello”;</p>
<p>  test.length;           //5</p>
<p>  test.length = 1;<br>  test.length;           //5</p>
<h4 id="5-5-Base64转码"><a href="#5-5-Base64转码" class="headerlink" title="5.5 Base64转码"></a>5.5 Base64转码</h4><p>主要作用是，将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。</p>
<h5 id="1）两个原生方法"><a href="#1）两个原生方法" class="headerlink" title="1）两个原生方法"></a>1）两个原生方法</h5><ul>
<li><p>btoa()将任意值转变成Base64</p>
</li>
<li><p>atob()将Base64转换成原来的值</p>
</li>
</ul>
<p>  #####2）转换字符</p>
<p>  这个方法对于ASCII码的字符支持很差，需要加一个中间环节</p>
<pre><code>  function b64Encode(str) {

    return btoa(encodeURIComponent(str));

  }

function b64Decode(str) {

    return decodeURIComponent(atob(str));

  }

b64Encode(&apos;你好&apos;)                        // &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;
b64Decode(&apos;JUU0JUJEJUEwJUU1JUE1JUJE&apos;)   // &quot;你好&quot;</code></pre><hr>
<h3 id="6，对象"><a href="#6，对象" class="headerlink" title="6，对象"></a>6，对象</h3><p>  对象是一种十分特别的数据类型，是由各种原始类型组合而成的“键值对”集合。</p>
<h4 id="6-1键名"><a href="#6-1键名" class="headerlink" title="6.1键名"></a>6.1键名</h4><p>  对象的所有键名都是字符串，在定义的时候键名会被自动转换成字符串，数值也会被转换成字符串</p>
<pre><code>var obj = {
  a:1,
  b:2

}

等价于

var obj = {

  &apos;a&apos;:1,
  &apos;b&apos;:2

}</code></pre><h4 id="6-2-引用"><a href="#6-2-引用" class="headerlink" title="6.2 引用"></a>6.2 引用</h4><p>  这个和c语言的指针真的很像，都是存的是内存地址，如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。这是对象与原始类型的最大的区别。</p>
<pre><code>var obj = {hehe:1};
var n = 1;

function a(test){

    test.hehe = 2;



}

a(obj);        //这里传入的是这个对象
               //这样test和obj所引用的内存地址完全相同
               //这样修改其中一个就会影响到其他的
a(n);
console.log(obj.hehe);
console.log(n)</code></pre><h4 id="6-3-属性"><a href="#6-3-属性" class="headerlink" title="6.3 属性"></a>6.3 属性</h4><h5 id="1）-和"><a href="#1）-和" class="headerlink" title="1）.和[]"></a>1）<code>.</code>和<code>[]</code></h5><p>  个人认为<code>.</code>这种方法看似简单好用，但实际上功能不是很全面。因为如果想要通过字符串变量来使用属性，就只能使用<code>[]</code>,还有当键名是数字时也没办法使用<code>.</code>。</p>
<pre><code>  var obj = {

    name:&apos;zjy&apos;,
    gender:&apos;female&apos;,
    1:666
  }


var a = name;
var b = 1;

obj.a;                //undefined
obj.name              //zjy
obj.1                 //报错啦Uncaught SyntaxError: Unexpected number
                      // 未捕获的语法错误：意料之外的数字
obj.b                 //undefined

obj[&apos;a&apos;]              //undefined
obj[&apos;name&apos;]           //zjy
obj[a]                //zjy
obj[1]                //666
obj[&apos;1&apos;]              //666
obj[b]                //666</code></pre><h5 id="2-查看属性"><a href="#2-查看属性" class="headerlink" title="2)查看属性"></a>2)查看属性</h5><p>  <code>Object.keys()</code>方法</p>
<pre><code>  var obj = {
  key1: 1,
  key2: 2
};

Object.keys(obj);       //[&apos;key1&apos;, &apos;key2&apos;]</code></pre><p>#####3) 删除属性<br>delete命令用于删除对象的属性，删除成功后返回true。不管删除的属性是否存在都会返回true</p>
<pre><code>var obj = {

  a:1,
  b:2

}

Object.keys(obj)    //[&apos;a&apos;,&apos;b&apos;]

delete obj.a        //true

Object.keys(obj)    //[&apos;b&apos;]</code></pre><h5 id="4-in"><a href="#4-in" class="headerlink" title="4) in"></a>4) <code>in</code></h5><pre><code>不管是不是继承的属性都会返回ture

    var obj = {

        a:1,
        b:2

    }

   &apos;a&apos; in obj;           // true
   &apos;toString&apos; in obj     //true</code></pre><ul>
<li><p>判断是否是自身的属性 <code>hasOwnProperty</code></p>
<pre><code>var obj = {};
if (&apos;toString&apos; in obj) {
  console.log(obj.hasOwnProperty(&apos;toString&apos;)) // false
}</code></pre></li>
</ul>
<h5 id="5-遍历属性：for…in"><a href="#5-遍历属性：for…in" class="headerlink" title="5) 遍历属性：for…in"></a>5) 遍历属性：for…in</h5><ul>
<li>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。</li>
<li>它不仅遍历对象自身的属性，还遍历继承的属性。</li>
<li>可以设置属性的可遍历性，有些继承属性并不会被遍历到就是这个原因。</li>
</ul>
<pre><code>var obj = {

  a:1,
  b:2

}

obj.toString();         //&quot;[object Object]&quot;

for(var i in obj){

  console.log(i);

}                       // a b</code></pre><ul>
<li>也可以使用<code>hasOwnProperty</code>判断是不是自身属性。</li>
</ul>
<h5 id="6）with"><a href="#6）with" class="headerlink" title="6）with"></a>6）<code>with</code></h5><p>  操作同一个对象的多个属性 </p>
<pre><code>var obj = {
  p1: 1,
  p2: 2,
};
with (obj) {
  p1 = 4;
  p2 = 5;
}</code></pre><p>  这个属性尽量不要使用，当操作obj中不存在的属性时，传建一个全局变量，不建议使用</p>
<h4 id="7，类型的转换"><a href="#7，类型的转换" class="headerlink" title="7，类型的转换"></a>7，类型的转换</h4><h5 id="7-1转成Sstring"><a href="#7-1转成Sstring" class="headerlink" title="7.1转成Sstring"></a>7.1转成Sstring</h5><h6 id="1-window-string"><a href="#1-window-string" class="headerlink" title="1) window.string()"></a>1) <code>window.string()</code></h6><pre><code>window.String(1)                 //&quot;1&quot;
window.String(ture)              //&quot;true&quot;
window.String(undefined)         //undefined
window.String(({a:1}))           //&quot;[object Object]&quot;
window.String(null)              //&quot;null&quot;</code></pre><h5 id="2-xxx-toString"><a href="#2-xxx-toString" class="headerlink" title="2) xxx.toString()"></a>2) <code>xxx.toString()</code></h5><p>  这个属性很常用但是功能的局限性也很大。</p>
<pre><code>var a = 1;
a.toString();                 //&quot;1&quot;

a = true;
a.toString();                 //&quot;ture&quot;

a = false;
a.toString();                 //&quot;false&quot;

a = null;
a.toString();                 //Uncaught TypeError: Cannot read property &apos;toString&apos; of null

a = undefined;
a.toString();                 //Uncaught TypeError: Cannot read property &apos;toString&apos; of undefined

a = {aa:1};
a.toString()                  //&quot;[object Object]&quot;</code></pre><h5 id="3-quot-quot"><a href="#3-quot-quot" class="headerlink" title="3) +&quot;&quot;"></a>3) <code>+&quot;&quot;</code></h5><p>  比较常用并且效果很好，加号的性质是，如果两个不同数据类型的数据相加，会优先转换成字符串</p>
<pre><code>1 + &quot;1&quot;                //&quot;11&quot;

1+&quot;1&quot;+true             //&quot;11true&quot;

1+true+1               //&quot;21&quot;</code></pre><p>  将想要转换成字符串的数据加一个””(是空字符串，不是空格字符串)</p>
<pre><code>1 + &quot;&quot;                //&quot;1&quot;
true + &quot;&quot;             //&quot;true&quot;
false + &quot;&quot;            //&quot;false&quot;
null + &quot;&quot;             //&quot;null&quot;
undefined+ &quot;&quot;         //&quot;undefined&quot;</code></pre><h4 id="7-2-转成Boolean"><a href="#7-2-转成Boolean" class="headerlink" title="7.2 转成Boolean"></a>7.2 转成Boolean</h4><h5 id="1-Boolean"><a href="#1-Boolean" class="headerlink" title="1) Boolean()"></a>1) <code>Boolean()</code></h5><pre><code>Boolean(1);             //ture
Boolean(0);             //false 
Boolean(null);          //false</code></pre><h5 id="2-1"><a href="#2-1" class="headerlink" title="2) !!"></a>2) <code>!!</code></h5><pre><code>!!1                     //true
!!0                     //false</code></pre><h5 id="3-5个会转换成false的特殊值-falsy值"><a href="#3-5个会转换成false的特殊值-falsy值" class="headerlink" title="3) 5个会转换成false的特殊值(falsy值)"></a>3) 5个会转换成<code>false</code>的特殊值(falsy值)</h5><ul>
<li>0</li>
<li>NaN</li>
<li>null</li>
<li>undefined</li>
<li>“”</li>
</ul>
<h4 id="7-3-转成Number"><a href="#7-3-转成Number" class="headerlink" title="7.3 转成Number"></a>7.3 转成Number</h4><h5 id="1-Number"><a href="#1-Number" class="headerlink" title="1) Number()"></a>1) Number()</h5><pre><code>Number(&quot;&quot;);             //0
Number(&quot; &quot;);            //0
Number(&quot;1&quot;)             //1
Number(&quot;1.23&quot;)          //1.23
Number(&quot;123a&quot;)          //NaN
Number(true);           //1
Number(false);          //0
Number(null);           //0
Number(undefined);      //0</code></pre><h5 id="2-parseInt"><a href="#2-parseInt" class="headerlink" title="2) parseInt"></a>2) <code>parseInt</code></h5><p>  在处理小数字符串，空字符串，空格字符串，带字母的字符串以及<code>Null</code> <code>undefined</code> <code>Boolean</code>时与Number不同。</p>
<ul>
<li><p>默认转换成10进制</p>
<pre><code>parseInt(&quot;&quot;);           //NaN
parseInt(&quot; &quot;);          //NaN
parseInt(&quot;123aaa&quot;);     //123
parseInt(&quot;aaa123&quot;);     //NaN
parseInt(&quot;1.23&quot;);       //1
parseInt(&quot;0x10&quot;);       //16
parseInt(&quot;011&quot;);        //11

parseInt(true)          //NaN
parseInt(false)         //NaN

parseInt(null)          //NaN
parseInt(undefined)     //NaN</code></pre></li>
<li><p>加上进制参数,</p>
<pre><code>parseInt(222,2);      //NaN
parseInt(111,2);      //7
parseInt(1f,30);      //45</code></pre><h5 id="3-parseFloat"><a href="#3-parseFloat" class="headerlink" title="3) parseFloat"></a>3) <code>parseFloat</code></h5><p>除了在处理小数字符串时不会将点后面的内容忽略，其余和<code>parseInt</code>基本相同。</p>
</li>
</ul>
<h5 id="4-0"><a href="#4-0" class="headerlink" title="4) -0"></a>4) -0</h5><pre><code>基本等同于Number,下面是两者之间的差异

    undefined - 0           //NaN</code></pre><h5 id="5"><a href="#5" class="headerlink" title="5) +"></a>5) <code>+</code></h5><pre><code>和-0效果相同</code></pre><h3 id="8，深拷贝vs浅拷贝"><a href="#8，深拷贝vs浅拷贝" class="headerlink" title="8，深拷贝vs浅拷贝"></a>8，深拷贝vs浅拷贝</h3><p>基本类型的简单赋值就是深拷贝,但是一般不会考虑基本类型。只会考虑对象的深拷贝。</p>
<pre><code>var a = 1;
var b = a;
b = 3;
console.log(a);       //1
console.log(b);       //3</code></pre><p>对象默认的赋值方式就是浅拷贝</p>
<pre><code>var a = {test :1};
var b = a ;
b.test = 2;
console.log(a.test);  //2
console.log(b.test);  //2</code></pre>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-layout" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/31/layout/">layout</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/07/31/layout/" class="article-date">
  <time datetime="2019-07-31T06:25:25.000Z" itemprop="datePublished">2019-07-31</time>
</a>
    
    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/">CSS</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>  <a href="#盒模型">1，盒模型</a></p>
<p>  <a href="#display属性">2，display属性</a></p>
<p>  <a href="#floa属性">3，float属性</a></p>
<p>  <a href="#position属性">4，position属性</a></p>
<p>  <a href="#常见布局">5，常见布局</a></p>
<hr>
<h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>  <img src="/zjyshy.github.io/img/boxmodel.png" alt="盒模型"></p>
<h4 id="1-1-box-sizing"><a href="#1-1-box-sizing" class="headerlink" title="1.1 box-sizing"></a>1.1 box-sizing</h4><p>  这个属性至关重要，它可以改变盒模型计算大小的方式，他有两个主要属性<code>content-box</code> <code>border-box</code></p>
<ul>
<li><p><code>centent-box</code></p>
<p> 是默认值，当我们设置<code>width</code>时，会把<code>border</code>和<code>padding</code>的值排除在外。</p>
<p> <code>width</code> = <code>content</code></p>
</li>
</ul>
<hr>
<ul>
<li><p><code>border-box</code></p>
<p>  将<code>border</code>和<code>padding</code>的值算入宽度。</p>
<p>  if <code>padding</code> + <code>border</code> &lt; <code>width</code>{
<br><br></p>
<p>   &nbsp;&nbsp; &nbsp;&nbsp; <code>width</code> = <code>content</code> + <code>padding</code><em>2 + <code>border</code></em>2;<br>   <br><br><br>  }else{<br><br><br><br>   &nbsp;&nbsp; &nbsp;&nbsp;<code>content</code> = 0;</p>
<p>   &nbsp;&nbsp; &nbsp;&nbsp; <code>width</code> = <code>padding</code><em>2 + <code>border</code></em>2;<br><br><br><br>  }</p>
<p>  <strong>对于<code>height</code>也有相同的结果</strong><br>  <br><br></p>
<p>当为<code>content-box</code>和<code>border-box</code>设置了相同的宽高时<br><a href="http://js.jirengu.com/wapos/2/edit?html,css,output" target="_blank" rel="noopener">例子</a></p>
</li>
</ul>
<h3 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h3><p>  任何布局方式都是建立在这个无比重要的属性上的。<br>  这个属性的值超级多，但是主要需要掌握的是<code>inline</code> <code>block</code> <code>inlin-block</code> <code>none</code></p>
<h4 id="常见取值"><a href="#常见取值" class="headerlink" title="常见取值"></a>常见取值</h4><h5 id="1-inline"><a href="#1-inline" class="headerlink" title="1.inline"></a>1.inline</h5><ul>
<li><strong>特点</strong>：高度和宽度由它的内容决定，没办法对一个inline元素设置<code>width</code>h和<code>height</code>。<code>margin-left</code> <code>margin-right</code>有效，但是<code>margin-top</code> <code>margin-bottom</code>将会无效。</li>
</ul>
<h5 id="2-block"><a href="#2-block" class="headerlink" title="2. block"></a>2. block</h5><ul>
<li><p><strong>特点</strong>：宽度由父元素决定，高度默认由内容决定，但是可以自行设置<code>width</code>和<code>height</code></p>
<h5 id="3-inline-block"><a href="#3-inline-block" class="headerlink" title="3. inline-block"></a>3. inline-block</h5></li>
<li><p><strong>特点</strong>：宽度由内容决定，但是除此之外都和block相同。</p>
<h5 id="4-none"><a href="#4-none" class="headerlink" title="4 none"></a>4 none</h5><p>设置了none属性的元素会</p>
</li>
</ul>
<h3 id="float属性"><a href="#float属性" class="headerlink" title="float属性"></a>float属性</h3><p> 这个词中文有漂浮、浮动之意。可以让元素在文档流里面飘起来,也就是从正常的文档流中移除~他会将除了<code>flex</code>和<code>inlin-flex</code>之外的<code>display</code>值全部改成<code>block</code>,但是在为设置它的宽度之前，宽度会受内容影响，状态更像<code>inline-blkock</code>。</p>
<h4 id="3-1-常见取值"><a href="#3-1-常见取值" class="headerlink" title="3.1 常见取值"></a>3.1 常见取值</h4><h5 id="left-amp-right"><a href="#left-amp-right" class="headerlink" title="left &amp; right"></a>left &amp; right</h5><p>  让元素向所在块的相应方向浮动。直到碰到所<code>block</code>处容器的边框,或者另一个<code>float</code>元素。</p>
<h4 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h4><p>  它是为了<code>float</code>而生。可用于浮动和非浮动元素。属性指定一个元素是否必须移动(清除浮动后)到在它之前的浮动元素下面。</p>
<h3 id="position属性"><a href="#position属性" class="headerlink" title="position属性"></a>position属性</h3><h4 id="常见取值-1"><a href="#常见取值-1" class="headerlink" title="常见取值"></a>常见取值</h4><h5 id="static"><a href="#static" class="headerlink" title="static"></a>static</h5><p>  默认值。该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。  </p>
<h5 id="relative-相对定位"><a href="#relative-相对定位" class="headerlink" title="relative 相对定位"></a>relative 相对定位</h5><p>  元素默认情况会被留在当前位置，并未脱离文档流。当设置了top等属性的时候，会在当前位置的基础上进行偏移。但是他会在原地留下空白。</p>
<h5 id="position-绝对定位"><a href="#position-绝对定位" class="headerlink" title="position 绝对定位"></a>position 绝对定位</h5><p>  脱离文档流，会根据最近的非static祖元素进行定位。</p>
<h3 id="常见布局"><a href="#常见布局" class="headerlink" title="常见布局"></a>常见布局</h3><h4 id="左右布局"><a href="#左右布局" class="headerlink" title="左右布局"></a>左右布局</h4><p>  这里就写我比较常用的方式吧。<a href="http://js.jirengu.com/helag/4/edit?html,css,output" target="_blank" rel="noopener">展示</a></p>
<h4 id="左中右布局"><a href="#左中右布局" class="headerlink" title="左中右布局"></a>左中右布局</h4><p>  <a href="http://js.jirengu.com/pesam/5/edit?html,css,output" target="_blank" rel="noopener">展示</a></p>
<h4 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h4><p>  <a href="http://js.jirengu.com/fidop/2/edit?html,css,output" target="_blank" rel="noopener">展示</a></p>
<h4 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h4><p>  作为css居中的一大难点，我会多罗列几种方法。flex布局会另写一篇博客这里先不谈。</p>
<ul>
<li>三种方法：<br><a href="http://js.jirengu.com/jitoj/3/edit?html,css,output" target="_blank" rel="noopener">展示</a></li>
</ul>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-table" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/27/table/">table</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/07/27/table/" class="article-date">
  <time datetime="2019-07-27T12:04:09.000Z" itemprop="datePublished">2019-07-27</time>
</a>
    
    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/">HTML</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><p>  表示表格数据 — 即通过二维数据表表示的信息。</p>
<h3 id="可包含的内容"><a href="#可包含的内容" class="headerlink" title="可包含的内容"></a>可包含的内容</h3><ul>
<li>tbody</li>
<li>thead</li>
<li>tfoot</li>
<li>caption</li>
<li>colgroup</li>
<li>tr</li>
</ul>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-form" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/form/">form</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/07/25/form/" class="article-date">
  <time datetime="2019-07-25T09:13:38.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/">HTML</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <hr>
<h3 id="form"><a href="#form" class="headerlink" title="form"></a>form</h3><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul>
<li><p>action </p>
<p> 规定了向谁提交</p>
</li>
<li><p>method</p>
<ul>
<li>默认是GET但是一般都会改成POST</li>
</ul>
</li>
<li></li>
</ul>
<h5 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h5><ul>
<li><p><strong>form是POST请求，a是GET请求</strong></p>
</li>
<li><p><strong>form的提交按钮是必不可少的</strong></p>
</li>
</ul>
<hr>
<h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><p>  这个标签就属于是form的内部标签，只有两者合作才会发挥作用</p>
<h5 id="label"><a href="#label" class="headerlink" title="label"></a>label</h5><p>  点击label中的内容就可以自动聚焦到相应的input</p>
<p>  label有两种使用方式：</p>
<blockquote>
<p>1，for 和 id对应</p>
<blockquote>
<pre><code>&lt;label for = &quot;test&quot;&gt;hi&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;hi&quot;id=&quot;test&quot;&gt;</code></pre><p><label for="test">hi</label><input type="text" id="test"></p>
</blockquote>
</blockquote>
<blockquote>
<p>2，将input嵌入label内</p>
<blockquote>
<pre><code>&lt;label&gt;hei&lt;input type=&quot;text&quot;name=&quot;hi&quot;&gt;&lt;/label&gt;</code></pre></blockquote>
</blockquote>
<h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><ul>
<li><p>submit 提交按钮</p>
<p>这个可以说form不可或缺的一项，没有它form里面的内容就没办法提交。</p>
</li>
</ul>
<pre><code>    &lt;input type=submit value=点我啊&gt;

&lt;input type=submit value=点我啊&gt;</code></pre><ul>
<li><p>radio 单选按钮</p>
<p>这个属性值要结合name属性使用，当radio的name值相同时，就只能选中一个，checked属性用来决定默认选中项。必须使用 value 属性定义此控件被提交时的值。</p>
<p>性别 男<input type="radio" value="male" name="gender" checked><br>   女<input type="radio" value="female" name="gender"></p>
</li>
</ul>
<pre><code>性别 男&lt;input type=radio value=&quot;male&quot; name=&quot;gender&quot; checked&gt;
女&lt;input type=radio value=&quot;female&quot; name=&quot;gender&quot;&gt;</code></pre><ul>
<li><p>checkbox 复选框</p>
<p>这个属性复选框。必须使用 value 属性定义此控件被提交时的值。使用 checked 属性指示控件是否被选择。也可以使用 indeterminate 指示复选框在一种不确定状态（大多数平台上，显示为一条穿过复选框的水平线）。</p>
</li>
</ul>
<pre><code>苹果&lt;input type=checkbox value=&quot;apple&quot;  name=&quot;fruit&quot;&gt;
橘子&lt;input type=checkbox value=&quot;orange&quot; name=&quot;fruit&quot;&gt;
香蕉&lt;input type=checkbox value=&quot;banana&quot; name=&quot;fruit&quot;&gt;



    苹果&lt;input type=checkbox value=&quot;apple&quot;  name=&quot;fruit&quot;&gt;
    橘子&lt;input type=checkbox value=&quot;orange&quot; name=&quot;fruit&quot;&gt;
    香蕉&lt;input type=checkbox value=&quot;banana&quot; name=&quot;fruit&quot;&gt;</code></pre><ul>
<li><p>color 颜色控件</p>
<p>用来创建一个允许用户使用颜色选择器，或输入兼容CSS语法的颜色代码的区域。（不支持Alpha通道），value可以用来指定默认颜色。</p>
</li>
</ul>
<pre><code>&lt;input type=&quot;color&quot; value=&quot;#ff0000&quot; /&gt;</code></pre><ul>
<li><p>atetime-local 时间控件</p>
<p>用于输入日期时间控件，不包含时区</p>
<ul>
<li>value可以设置默认时间</li>
</ul>
</li>
</ul>
  <input id="party" type="datetime-local" name="partydate" value="2017-06-01T08:30">


<pre><code>&lt;input id=&quot;party&quot; type=&quot;datetime-local&quot; name=&quot;partydate&quot; value=&quot;2017-06-01T08:30&quot;&gt;</code></pre><ul>
<li><p>email</p>
<p>会自动检测是否是合法的email地址</p>
<input type="email" name="email">


</li>
</ul>
<pre><code>&lt;input type=&quot;email&quot; name=&quot;email&quot;&gt;</code></pre><ul>
<li><p>img </p>
<p>一个图片提交按钮</p>
  <input type="image" src="img/xxx">



</li>
</ul>
<ul>
<li><p>text</p>
<blockquote>
<p>特有属性</p>
<blockquote>
<ul>
<li>maxlength    文本框能接受的最大字符数。</li>
<li>minlength    文本框能输入的最小字符数，并且仍然被认为是有效的。</li>
<li>pattern     验证文本框内容的正则表达式。</li>
<li>placeholder    文本框为空时显示的一个示例值。</li>
<li>readonly    一个布尔属性，指示文本框中的内容是否应该为只读。</li>
<li>size    一个数字，指示文本框有多少个字符宽度。</li>
<li>spellcheck    控制是否可以检查文本框的拼写,或者默认的拼写检查配置是否应该使用。 </li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
<input type="text" size="10" placeholder="hehe" name="username" maxlength="2">

<pre><code>&lt;input type = text size = 7  placeholder = hehe name = username maxlength = 2&gt;</code></pre><ul>
<li>range</li>
</ul>
<blockquote>
<p>特有属性</p>
<blockquote>
<ul>
<li>max允许的最大值</li>
<li>min最小允许值 </li>
<li>step步进间隔，用于用户界面和验证目的</li>
</ul>
</blockquote>
</blockquote>
  <input type="range" max="15" min="0" step="3">

<pre><code>&lt;input type=&quot;range&quot; max = 15 min = 0 step = 3  name = value&gt;</code></pre><p>这些感觉平时比较常见，其他的等到用的时候再补充吧。</p>
<hr>
<h3 id="select-和-option下拉菜单"><a href="#select-和-option下拉菜单" class="headerlink" title="select 和 option下拉菜单"></a>select 和 option下拉菜单</h3><ul>
<li>autocomplete</li>
</ul>
<pre><code>DOMString 提供用户代理自动完成功能的提示。 有关完整值的完整列表以及有关如何使用自动完成的详细信息，请参阅HTML自动完成属性。
*****</code></pre><ul>
<li><p>autofocus</p>
<p>这个属性能够让一个对象在页面加载的时候获得焦点. 在一个页面上下文中, 只有一个对象可以有这个属性，并且是布尔值(true 或者 false).</p>
<hr>
</li>
<li><p>disabled</p>
<p>这个布尔值的属性表明一个用户是否可以操控该表单对象. 如果这个属性没有被明确定义, 则从它的父元素继承, 例如 fieldset; 如果没有父元素设置 disabled 属性, 那么默认该表单对象 enabled.</p>
<hr>
</li>
<li><p>form</p>
<p>select所关联的form表单 (它的”表单拥有者”). 如果这个属性被明确定义, 那么它的值一定是在同一个document中表单ID. 这样能够让你把select标签放在任何的位置, 不仅限于作为form表单的后代元素.</p>
<hr>
</li>
<li><p>multiple</p>
<p>这个布尔值的属性标记select是否可以多选. 默认是单选.</p>
<hr>
</li>
<li><p>name</p>
<p>控件名称</p>
<hr>
</li>
<li><p>required HTML5<br>规定select的值不能为空(布尔值).</p>
<hr>
</li>
<li><p>size</p>
<p>如果控件显示为滚动列表框，则此属性表示为控件中同时可见的行数。浏览器不需要将选择元素呈现为滚动列表框。默认值为0</p>
<hr>
<p><code>option</code>的<code>selected</code>默认选中</p>
<select multiple name="timezone_offset" id="timezone-offset" class="span5">
      <option value="-12:00">(GMT -12:00) Eniwetok, Kwajalein</option>
      <option selected value="-11:00">(GMT -11:00) Midway Island, Samoa</option>
      <option value="-10:00">(GMT -10:00) Hawaii</option>
      <option selected value="-09:50">(GMT -9:30) Taiohae</option>
      <option value="-09:00">(GMT -9:00) Alaska</option>
      <option value="-08:00">(GMT -8:00) Pacific Time (US &amp; Canada)</option>


</select></li>
</ul>
<pre><code>&lt;/select&gt;


#### button

在form中添加了一个button的时候，它默认的type是submit</code></pre>
      
    </div>
    
  </div>
  
  
</article>

  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>


</section>
        <aside id="sidebar">
  
    <div class="widget-box">
  <div class="avatar-box">
    <img class="avatar" src="/images/default-avatar.webp" title="图片来自网络">
    <h3 class="avatar-name">
      
        施振兴
      
    </h3>
    <p class="avatar-slogan">
      前端！前端！前端！变强!变强!变强!
    </p>
  </div>
</div>


  
    

  
    
  <div class="widget-box">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机基础/">计算机基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/HTML/" style="font-size: 20px;">HTML</a> <a href="/tags/JavaScript/" style="font-size: 13.33px;">JavaScript</a> <a href="/tags/前端/" style="font-size: 10px;">前端</a> <a href="/tags/工具/" style="font-size: 16.67px;">工具</a> <a href="/tags/网络/" style="font-size: 13.33px;">网络</a> <a href="/tags/计算机基础/" style="font-size: 13.33px;">计算机基础</a>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/04/addEventListener事件/">addEventListener事件</a>
          </li>
        
          <li>
            <a href="/2019/09/03/实现jQuery部分功能/">实现jQuery部分功能</a>
          </li>
        
          <li>
            <a href="/2019/08/29/Array对象/">Array对象</a>
          </li>
        
          <li>
            <a href="/2019/08/28/原型链/">原型链</a>
          </li>
        
          <li>
            <a href="/2019/08/15/面试题/">面试题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
      <div class="widget-box">
    <h3 class="widget-title">友链</h3>
    <div class="widget">
      
        <a style="display: block;" href="https://yiluyanxia.github.io/" title target="_blank">一路眼瞎</a>
      
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer">
  <div class="foot-box global-width">
    &copy; 2019 John Doe &nbsp;&nbsp;
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    &nbsp;|&nbsp;主题 <a href="https://github.com/yiluyanxia/hexo-theme-antiquity">antiquity</a>
    <br>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">不蒜子告之   阁下是第<span id="busuanzi_value_site_pv"></span>个访客</span>
  </div>
</footer>
      <script src="https://code.jquery.com/jquery-2.0.3.min.js"></script>
<script>
if (!window.jQuery) {
var script = document.createElement('script');
script.src = "/js/jquery-2.0.3.min.js";
document.body.write(script);
}
</script>

  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



    </div>
    <nav id="mobile-nav" class="mobile-nav-box">
  <div class="mobile-nav-img mobile-nav-top"></div>
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
  <div class="mobile-nav-img  mobile-nav-bottom"></div>
</nav>    
  </div>
</body>
</html>